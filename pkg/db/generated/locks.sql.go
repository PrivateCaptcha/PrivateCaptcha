// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: locks.sql

package generated

import (
	"context"

	"time"
)

const deleteLock = `-- name: DeleteLock :exec
DELETE FROM locks WHERE name = $1
`

func (q *Queries) DeleteLock(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteLock, name)
	return err
}

const insertLock = `-- name: InsertLock :one
INSERT INTO locks (name, data, expires_at)
VALUES ($1, $2, NOW() + $3::INTERVAL)
ON CONFLICT (name) DO UPDATE
SET expires_at = EXCLUDED.expires_at
WHERE locks.expires_at <= NOW()
RETURNING name, data, expires_at
`

type InsertLockParams struct {
	Name    string        `db:"name" json:"name"`
	Data    []byte        `db:"data" json:"data"`
	Column3 time.Duration `db:"column_3" json:"column_3"`
}

func (q *Queries) InsertLock(ctx context.Context, arg *InsertLockParams) (*Lock, error) {
	row := q.db.QueryRow(ctx, insertLock, arg.Name, arg.Data, arg.Column3)
	var i Lock
	err := row.Scan(&i.Name, &i.Data, &i.ExpiresAt)
	return &i, err
}
