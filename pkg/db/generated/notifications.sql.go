// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: notifications.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLastActiveNotification = `-- name: GetLastActiveNotification :one
SELECT id, message, start_date, end_date, user_id, is_active FROM backend.system_notifications
 WHERE is_active = TRUE AND
   start_date <= $1::timestamptz AND
   (end_date IS NULL OR end_date > $1::timestamptz) AND
   (user_id = $2 OR user_id IS NULL)
 ORDER BY
   CASE WHEN user_id = $2 THEN 0 ELSE 1 END,
   start_date DESC
 LIMIT 1
`

type GetLastActiveNotificationParams struct {
	Column1 pgtype.Timestamptz `db:"column_1" json:"column_1"`
	UserID  pgtype.Int4        `db:"user_id" json:"user_id"`
}

func (q *Queries) GetLastActiveNotification(ctx context.Context, arg *GetLastActiveNotificationParams) (*SystemNotification, error) {
	row := q.db.QueryRow(ctx, getLastActiveNotification, arg.Column1, arg.UserID)
	var i SystemNotification
	err := row.Scan(
		&i.ID,
		&i.Message,
		&i.StartDate,
		&i.EndDate,
		&i.UserID,
		&i.IsActive,
	)
	return &i, err
}

const getNotificationById = `-- name: GetNotificationById :one
SELECT id, message, start_date, end_date, user_id, is_active FROM backend.system_notifications WHERE id = $1
`

func (q *Queries) GetNotificationById(ctx context.Context, id int32) (*SystemNotification, error) {
	row := q.db.QueryRow(ctx, getNotificationById, id)
	var i SystemNotification
	err := row.Scan(
		&i.ID,
		&i.Message,
		&i.StartDate,
		&i.EndDate,
		&i.UserID,
		&i.IsActive,
	)
	return &i, err
}
