// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: usage_limits.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUsageLimitViolations = `-- name: AddUsageLimitViolations :exec
INSERT INTO usage_limit_violations (user_id, paddle_product_id, requests_limit, requests_count, detection_date)
SELECT unnest($1::INT[]) AS user_id,
       unnest($2::TEXT[]) AS paddle_product_id,
       unnest($3::BIGINT[]) AS requests_limit,
       unnest($4::BIGINT[]) AS requests_count,
       unnest($5::date[]) AS detection_date
ON CONFLICT (user_id, paddle_product_id, detection_date)
DO UPDATE SET
    paddle_product_id = EXCLUDED.paddle_product_id,
    requests_limit = EXCLUDED.requests_limit,
    requests_count = EXCLUDED.requests_count,
    detection_date = EXCLUDED.detection_date
`

type AddUsageLimitViolationsParams struct {
	UserIds  []int32       `db:"user_ids" json:"user_ids"`
	Products []string      `db:"products" json:"products"`
	Limits   []int64       `db:"limits" json:"limits"`
	Counts   []int64       `db:"counts" json:"counts"`
	Dates    []pgtype.Date `db:"dates" json:"dates"`
}

func (q *Queries) AddUsageLimitViolations(ctx context.Context, arg *AddUsageLimitViolationsParams) error {
	_, err := q.db.Exec(ctx, addUsageLimitViolations,
		arg.UserIds,
		arg.Products,
		arg.Limits,
		arg.Counts,
		arg.Dates,
	)
	return err
}
