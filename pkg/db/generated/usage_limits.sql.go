// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: usage_limits.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUsageLimitViolations = `-- name: AddUsageLimitViolations :exec
INSERT INTO backend.usage_limit_violations (user_id, external_product_id, requests_limit, requests_count, detection_month, last_violated_at)
SELECT unnest($1::INT[]) AS user_id,
       unnest($2::TEXT[]) AS external_product_id,
       unnest($3::BIGINT[]) AS requests_limit,
       unnest($4::BIGINT[]) AS requests_count,
       date_trunc('month', unnest($5::date[])) AS detection_month,
       unnest($5::date[]) AS last_violated_at
ON CONFLICT (user_id, external_product_id, detection_month)
DO UPDATE SET
    external_product_id = EXCLUDED.external_product_id,
    requests_limit = EXCLUDED.requests_limit,
    requests_count = EXCLUDED.requests_count,
    last_violated_at = GREATEST(usage_limit_violations.last_violated_at, EXCLUDED.last_violated_at)
`

type AddUsageLimitViolationsParams struct {
	UserIds  []int32       `db:"user_ids" json:"user_ids"`
	Products []string      `db:"products" json:"products"`
	Limits   []int64       `db:"limits" json:"limits"`
	Counts   []int64       `db:"counts" json:"counts"`
	Dates    []pgtype.Date `db:"dates" json:"dates"`
}

func (q *Queries) AddUsageLimitViolations(ctx context.Context, arg *AddUsageLimitViolationsParams) error {
	_, err := q.db.Exec(ctx, addUsageLimitViolations,
		arg.UserIds,
		arg.Products,
		arg.Limits,
		arg.Counts,
		arg.Dates,
	)
	return err
}

const getUsersWithConsecutiveViolations = `-- name: GetUsersWithConsecutiveViolations :many
SELECT u.id, u.name, u.email, u.subscription_id, u.created_at, u.updated_at, u.deleted_at
FROM backend.usage_limit_violations v1
JOIN backend.usage_limit_violations v2 ON v1.user_id = v2.user_id
JOIN backend.users u ON v1.user_id = u.id
JOIN backend.subscriptions s ON u.subscription_id = s.id
WHERE s.external_product_id = v1.external_product_id
  AND u.deleted_at IS NULL
  AND EXTRACT(YEAR FROM v1.detection_month) = EXTRACT(YEAR FROM CURRENT_DATE)
  AND EXTRACT(MONTH FROM v1.detection_month) = EXTRACT(MONTH FROM CURRENT_DATE)
  AND EXTRACT(YEAR FROM v2.detection_month) = EXTRACT(YEAR FROM CURRENT_DATE - INTERVAL '1 MONTH')
  AND EXTRACT(MONTH FROM v2.detection_month) = EXTRACT(MONTH FROM CURRENT_DATE - INTERVAL '1 MONTH')
`

type GetUsersWithConsecutiveViolationsRow struct {
	User User `db:"user" json:"user"`
}

func (q *Queries) GetUsersWithConsecutiveViolations(ctx context.Context) ([]*GetUsersWithConsecutiveViolationsRow, error) {
	rows, err := q.db.Query(ctx, getUsersWithConsecutiveViolations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUsersWithConsecutiveViolationsRow
	for rows.Next() {
		var i GetUsersWithConsecutiveViolationsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.SubscriptionID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithLargeViolations = `-- name: GetUsersWithLargeViolations :many
SELECT u.id, u.name, u.email, u.subscription_id, u.created_at, u.updated_at, u.deleted_at, uv.user_id, uv.external_product_id, uv.requests_limit, uv.requests_count, uv.detection_month, uv.last_violated_at, s.status as status
FROM backend.users u
JOIN backend.usage_limit_violations uv ON u.id = uv.user_id
JOIN backend.subscriptions s ON u.subscription_id = s.id
WHERE s.external_product_id = uv.external_product_id
  AND u.deleted_at IS NULL
  AND uv.requests_count >= ($1::float * uv.requests_limit)
  AND uv.last_violated_at >= $2::date
`

type GetUsersWithLargeViolationsParams struct {
	Column1 float64     `db:"column_1" json:"column_1"`
	Column2 pgtype.Date `db:"column_2" json:"column_2"`
}

type GetUsersWithLargeViolationsRow struct {
	User                User                `db:"user" json:"user"`
	UsageLimitViolation UsageLimitViolation `db:"usage_limit_violation" json:"usage_limit_violation"`
	Status              string              `db:"status" json:"status"`
}

func (q *Queries) GetUsersWithLargeViolations(ctx context.Context, arg *GetUsersWithLargeViolationsParams) ([]*GetUsersWithLargeViolationsRow, error) {
	rows, err := q.db.Query(ctx, getUsersWithLargeViolations, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUsersWithLargeViolationsRow
	for rows.Next() {
		var i GetUsersWithLargeViolationsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.SubscriptionID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.UsageLimitViolation.UserID,
			&i.UsageLimitViolation.ExternalProductID,
			&i.UsageLimitViolation.RequestsLimit,
			&i.UsageLimitViolation.RequestsCount,
			&i.UsageLimitViolation.DetectionMonth,
			&i.UsageLimitViolation.LastViolatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
