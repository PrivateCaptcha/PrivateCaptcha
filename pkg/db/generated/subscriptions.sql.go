// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: subscriptions.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO backend.subscriptions (paddle_product_id, paddle_price_id, paddle_subscription_id, paddle_customer_id, status, source, trial_ends_at, next_billed_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, paddle_product_id, paddle_price_id, paddle_subscription_id, paddle_customer_id, status, source, trial_ends_at, next_billed_at, cancel_from, created_at, updated_at
`

type CreateSubscriptionParams struct {
	PaddleProductID      string             `db:"paddle_product_id" json:"paddle_product_id"`
	PaddlePriceID        string             `db:"paddle_price_id" json:"paddle_price_id"`
	PaddleSubscriptionID pgtype.Text        `db:"paddle_subscription_id" json:"paddle_subscription_id"`
	PaddleCustomerID     pgtype.Text        `db:"paddle_customer_id" json:"paddle_customer_id"`
	Status               string             `db:"status" json:"status"`
	Source               SubscriptionSource `db:"source" json:"source"`
	TrialEndsAt          pgtype.Timestamptz `db:"trial_ends_at" json:"trial_ends_at"`
	NextBilledAt         pgtype.Timestamptz `db:"next_billed_at" json:"next_billed_at"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg *CreateSubscriptionParams) (*Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.PaddleProductID,
		arg.PaddlePriceID,
		arg.PaddleSubscriptionID,
		arg.PaddleCustomerID,
		arg.Status,
		arg.Source,
		arg.TrialEndsAt,
		arg.NextBilledAt,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.PaddleProductID,
		&i.PaddlePriceID,
		&i.PaddleSubscriptionID,
		&i.PaddleCustomerID,
		&i.Status,
		&i.Source,
		&i.TrialEndsAt,
		&i.NextBilledAt,
		&i.CancelFrom,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, paddle_product_id, paddle_price_id, paddle_subscription_id, paddle_customer_id, status, source, trial_ends_at, next_billed_at, cancel_from, created_at, updated_at FROM backend.subscriptions WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id int32) (*Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.PaddleProductID,
		&i.PaddlePriceID,
		&i.PaddleSubscriptionID,
		&i.PaddleCustomerID,
		&i.Status,
		&i.Source,
		&i.TrialEndsAt,
		&i.NextBilledAt,
		&i.CancelFrom,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSubscriptionsByUserIDs = `-- name: GetSubscriptionsByUserIDs :many
SELECT s.id, s.paddle_product_id, s.paddle_price_id, s.paddle_subscription_id, s.paddle_customer_id, s.status, s.source, s.trial_ends_at, s.next_billed_at, s.cancel_from, s.created_at, s.updated_at, u.id AS user_id
FROM backend.subscriptions s
JOIN backend.users u on u.subscription_id = s.id
WHERE u.id = ANY($1::INT[]) AND u.subscription_id IS NOT NULL
`

type GetSubscriptionsByUserIDsRow struct {
	Subscription Subscription `db:"subscription" json:"subscription"`
	UserID       int32        `db:"user_id" json:"user_id"`
}

func (q *Queries) GetSubscriptionsByUserIDs(ctx context.Context, dollar_1 []int32) ([]*GetSubscriptionsByUserIDsRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByUserIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetSubscriptionsByUserIDsRow
	for rows.Next() {
		var i GetSubscriptionsByUserIDsRow
		if err := rows.Scan(
			&i.Subscription.ID,
			&i.Subscription.PaddleProductID,
			&i.Subscription.PaddlePriceID,
			&i.Subscription.PaddleSubscriptionID,
			&i.Subscription.PaddleCustomerID,
			&i.Subscription.Status,
			&i.Subscription.Source,
			&i.Subscription.TrialEndsAt,
			&i.Subscription.NextBilledAt,
			&i.Subscription.CancelFrom,
			&i.Subscription.CreatedAt,
			&i.Subscription.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscription = `-- name: UpdateSubscription :one
UPDATE backend.subscriptions SET paddle_product_id = $2, status = $3, next_billed_at = $4, cancel_from = $5, updated_at = NOW() WHERE paddle_subscription_id = $1 RETURNING id, paddle_product_id, paddle_price_id, paddle_subscription_id, paddle_customer_id, status, source, trial_ends_at, next_billed_at, cancel_from, created_at, updated_at
`

type UpdateSubscriptionParams struct {
	PaddleSubscriptionID pgtype.Text        `db:"paddle_subscription_id" json:"paddle_subscription_id"`
	PaddleProductID      string             `db:"paddle_product_id" json:"paddle_product_id"`
	Status               string             `db:"status" json:"status"`
	NextBilledAt         pgtype.Timestamptz `db:"next_billed_at" json:"next_billed_at"`
	CancelFrom           pgtype.Timestamptz `db:"cancel_from" json:"cancel_from"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg *UpdateSubscriptionParams) (*Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscription,
		arg.PaddleSubscriptionID,
		arg.PaddleProductID,
		arg.Status,
		arg.NextBilledAt,
		arg.CancelFrom,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.PaddleProductID,
		&i.PaddlePriceID,
		&i.PaddleSubscriptionID,
		&i.PaddleCustomerID,
		&i.Status,
		&i.Source,
		&i.TrialEndsAt,
		&i.NextBilledAt,
		&i.CancelFrom,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
