// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: subscriptions.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (paddle_product_id, paddle_subscription_id, paddle_customer_id, status, trial_ends_at, next_billed_at) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, paddle_product_id, paddle_subscription_id, paddle_customer_id, status, trial_ends_at, next_billed_at, created_at, updated_at
`

type CreateSubscriptionParams struct {
	PaddleProductID      string             `db:"paddle_product_id" json:"paddle_product_id"`
	PaddleSubscriptionID string             `db:"paddle_subscription_id" json:"paddle_subscription_id"`
	PaddleCustomerID     string             `db:"paddle_customer_id" json:"paddle_customer_id"`
	Status               string             `db:"status" json:"status"`
	TrialEndsAt          pgtype.Timestamptz `db:"trial_ends_at" json:"trial_ends_at"`
	NextBilledAt         pgtype.Timestamptz `db:"next_billed_at" json:"next_billed_at"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg *CreateSubscriptionParams) (*Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.PaddleProductID,
		arg.PaddleSubscriptionID,
		arg.PaddleCustomerID,
		arg.Status,
		arg.TrialEndsAt,
		arg.NextBilledAt,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.PaddleProductID,
		&i.PaddleSubscriptionID,
		&i.PaddleCustomerID,
		&i.Status,
		&i.TrialEndsAt,
		&i.NextBilledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, paddle_product_id, paddle_subscription_id, paddle_customer_id, status, trial_ends_at, next_billed_at, created_at, updated_at FROM subscriptions WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id int32) (*Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.PaddleProductID,
		&i.PaddleSubscriptionID,
		&i.PaddleCustomerID,
		&i.Status,
		&i.TrialEndsAt,
		&i.NextBilledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateSubscription = `-- name: UpdateSubscription :one
UPDATE subscriptions SET status = $2, next_billed_at = $3, updated_at = NOW() WHERE id = $1 RETURNING id, paddle_product_id, paddle_subscription_id, paddle_customer_id, status, trial_ends_at, next_billed_at, created_at, updated_at
`

type UpdateSubscriptionParams struct {
	ID           int32              `db:"id" json:"id"`
	Status       string             `db:"status" json:"status"`
	NextBilledAt pgtype.Timestamptz `db:"next_billed_at" json:"next_billed_at"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg *UpdateSubscriptionParams) (*Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscription, arg.ID, arg.Status, arg.NextBilledAt)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.PaddleProductID,
		&i.PaddleSubscriptionID,
		&i.PaddleCustomerID,
		&i.Status,
		&i.TrialEndsAt,
		&i.NextBilledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
