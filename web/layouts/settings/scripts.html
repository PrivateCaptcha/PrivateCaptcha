{{define "scripts"}}
{{template "default-scripts.html" .}}
<script defer src="{{$.Ctx.CDN}}/portal/js/d3.v7.min.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript">
function loadScript(url, callback) {
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    // several events for cross browser compatibility.
    script.onreadystatechange = callback;
    script.onload = callback;
    // Fire the loading
    document.head.appendChild(script);
};

function openCheckout(priceIDs, annual) {
    if (!priceIDs) { return; }
    if (!Array.isArray(priceIDs)) { return; }
    if (priceIDs.length < 1) { return; }
    const selectedPrice = (priceIDs.length === 1) ? priceIDs[0] : priceIDs[annual ? 1 : 0];
    if (selectedPrice.length === 0) { return; }
    Paddle.Checkout.open({
                         items: [{
                             priceId: selectedPrice,
                             quantity: 1
                         }],
                         customer: {
                             email: "{{ .Params.Email }}"
                         },
                         customData: {
                             privateCaptchaUserID: "{{ .Params.UserID }}"
                         }
    });
}

function handlePaddleEventCallback(data) {
    switch(data.name) {
        case "checkout.completed":
            location.reload();
            break;
        default:
            // console.log(data);
            break;
    }
}

document.addEventListener('DOMContentLoaded', function (evt) {
    document.body.addEventListener("load-paddle", function(evt) {
        loadScript("https://cdn.paddle.com/paddle/v2/paddle.js",
                   function() {
                       Paddle.Environment.set("{{ .Params.PaddleEnvironment }}");
                       Paddle.Initialize({
                                         token: "{{ .Params.PaddleClientToken }}",
                                         eventCallback: handlePaddleEventCallback
                       });
                   });
    });
});
</script>

<script type="text/javascript">
    function chartComponent(usageLimit) {
        // Declare 'chart' with 'let' to prevent it from being reactive in Alpine.js. 
        let chart;

        const yTicksCount = 7;
        const maxBarWidth = 7;

        const backgroundColor = '#e4e4e7';
        const requestedColor = '#4f46e5';
        const verifiedColor = '#ffa600';
        const grayColor = "#6b7280";

        const monthlyFormat = d3.timeFormat("%b");

        const monthlyTicks = (date, i) => {
            var day = date.getDate();
            var month = date.getMonth();
            if ((day == 1) && (month == 0)) {
                return date.getFullYear();
            } else {
                return monthlyFormat(date);
            }
        };

        const yTickFormat = function(d) {
            if (d >= 1000000000) {
                return (d / 1000000000) + 'B'; // For values in billions
            } else if (d >= 1000000) {
                return (d / 1000000) + 'M'; // For values in millions
            } else if (d >= 1000) {
                return (d / 1000) + 'K'; // For values in thousands
            }
            return d; // For values less than 1000
        };

        const drawNoData = (element, xTickFunction, periodLengthDays) => {
            const margin = {top: 20, right: 30, bottom: 60, left: 30};
            const rect = element.getBoundingClientRect();

            let width = rect.width - margin.left - margin.right;
            let height = rect.height - margin.top - margin.bottom;

            let d3Selection = d3.select(element);
            d3Selection.selectAll('svg').remove();

            let svg = d3Selection
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            let chartElement = svg.append('g')
                .attr('class', 'charts')
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Create x scale
            let x = d3.scaleTime().range([0, width]);

            x.domain([d3.timeDay.offset(new Date(), -periodLengthDays), new Date()]);

            let xTickValues = x.domain().filter(function(d, i) { return !(i % 2); });

            let xAxis = d3.axisBottom(x)
                .tickValues(xTickValues)
                .tickFormat(xTickFunction);

            // Create y scale
            let y = d3.scaleLinear().range([height, 0]);

            // Create x axis
            chartElement.append('g')
                .attr('transform', 'translate(0,' + height + ')')
                .call(d3.axisBottom(x))
                .style("color", backgroundColor)
                .style("stroke-width", 2)
                .selectAll("text")
                .style("text-anchor", "end")
                .style("color", "#000")
                .attr("dx", "-.8em")
                .attr("dy", "-.55em")
                .attr("transform", "rotate(-90)" );

            // Create y axis with horizontal gridlines
            chartElement.append('g')
                .call(d3.axisLeft(y).ticks(yTicksCount).tickSize(-width).tickFormat(''))
                .style("color", backgroundColor)
                .selectAll(".domain").remove();

            chartElement.append("g")
              .attr("transform", "translate(" + (width / 2 - 80) + "," + (height / 2 + 5) + ")")
              .append("text")
              .text("No data available")
              .style("font-size", "20px")
              .style("fill", grayColor);
        }

        const setBarAttributes = (bars, x, y, height, color) => {
            const barSpacing = 2;
            bars.enter().append("rect")
                .attr("class", "bar")
                .attr("x", function(d) { 
                    let barWidth = Math.min(x.bandwidth(), maxBarWidth);
                    // Adjust the x position to center the bar over the tick
                    return x(d.x) + x.bandwidth() / 2;
                })
                .attr("width", function() { return Math.min(x.bandwidth(), maxBarWidth); })
                .attr("y", function(d) { return y(d.y); })
                .attr("height", function(d) { return d.y > 1e-6 ? height - y(d.y) : 0; })
                .attr("rx", 3)
                .attr("ry", 3)
                .attr("fill", color)
                .attr("opacity", 1)
                .on("mouseover", function() { d3.select(this).attr("opacity", 0.8); })
                .on("mouseout", function() { d3.select(this).attr("opacity", 1); })
                .append("title").text(function(d) { return d.y; });
        };

        const setLegend = (legend, text, color) => {
            // Add the legend color guide
            legend.append("circle")
                .attr("cx", -16)
                .attr("cy", 0)
                .attr("r", 6)
                .style("fill", color);

            // Add the legend text
            legend.append("text")
                .attr("x", 0)
                .attr("y", 0)
                .attr("dy", ".35em")
                .text(text)
                .attr("class", "textselected")
                .style("text-anchor", "start")
                .style("font-size", "14px");
        };

        const setChartData = (element, data, xTickFormat, usageLimit) => {
            const requested = data.data;
            // Convert unix timestamp to JavaScript Date object
            requested.forEach(d => { d.x = new Date(d.x * 1000); });

            const legendHeight = 50;
            const margin = {top: 20, right: 30, bottom: 30, left: 30};
            const rect = element.getBoundingClientRect();

            const width = rect.width - margin.left - margin.right;
            const height = rect.height - legendHeight - margin.top - margin.bottom;

            let d3Selection = d3.select(element);
            d3Selection.selectAll('svg').remove();

            let svg = d3Selection
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + legendHeight + margin.top + margin.bottom);

            let chartElement = svg.append('g')
                .attr('class', 'charts')
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            let x = d3.scaleBand().rangeRound([0, width]).padding(0.1);
            let y = d3.scaleLinear().range([height, 0]);

            // we will always have more or equal requested to verified
            x.domain(requested.map(function(d) { return d.x; }));
            y.domain([0, d3.max(requested, function(d) { return d.y; }) * 1.2]);

            // Filter the domain of the X scale to include only every other value
            let xTickValues = x.domain();

            let xAxis = d3.axisBottom(x)
                .tickValues(xTickValues)
                .tickFormat(xTickFormat);
            let yAxis = d3.axisLeft(y).ticks(yTicksCount).tickFormat(yTickFormat).tickPadding(5);

            // Add the grid lines
            let yGrid = chartElement.append("g")
                .attr("class", "grid")
                .call(yAxis.tickSize(-width))
                .style("color", backgroundColor);

            yGrid.selectAll("text").style("color", grayColor);
            yGrid.selectAll(".domain").remove();

            if (usageLimit) {
                // within 10% to the usageLimit
                const closeToTheLimit = requested.some(d => (1.1*d.y) >= usageLimit);
                if (closeToTheLimit) {
                    // add constant line for the limit
                    svg.append('line')
                        .attr('x1', 0)
                        .attr('x2', width)
                        .attr('y1', y(usageLimit))
                        .attr('y2', y(usageLimit))
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
                        .attr('stroke', verifiedColor)
                        .attr('stroke-width', 1)
                        .attr('stroke-dasharray', '5,5');
                }
            }

            // Append the rectangles for the bar chart
            let barsRequested = chartElement.selectAll("bar-requested").data(requested);
            setBarAttributes(barsRequested, x, y, height, requestedColor);

            // Add the x-axis
            chartElement.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis)
                .style("color", backgroundColor)
                .style("stroke-width", 2)
                .selectAll("text")
                .style("text-anchor", "end")
                .style("color", "#000")
                .attr("dx", "-.8em")
                .attr("dy", "-.55em")
                .attr("transform", "rotate(-90)" );

            const xAxisHeight = 30;

            let legendParent = chartElement.append("g")
                .attr("class", "legendParent")
                .attr("transform", "translate(" + (width / 2) + "," + (xAxisHeight + height + legendHeight/2) + ")");

            let legend1 = legendParent.append("g")
                .attr("class", "legend-requested");
            setLegend(legend1, 'Requests', requestedColor);
        };

        return {
            // https://d3js.org/d3-time-format#locale_format
            isLoading: false,
            usageLimit: usageLimit,
            async init() {
                this.updateChart();
            },
            async fetchChartData() {
                this.isLoading = true;
                try {
                    const response = await fetch('{{ partsURL $.Const.UserEndpoint $.Const.Stats }}');
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching chart data:', error);
                    return null;
                } finally {
                    this.isLoading = false;
                }
            },
            async updateChart() {
                const response = await this.fetchChartData();
                if (response && response.data && (response.data.length > 0)) {
                    setChartData(this.$refs.chart, response, monthlyTicks, this.usageLimit);
                } else {
                    drawNoData(this.$refs.chart, monthlyTicks, 365);
                }
            }
        }
    }
</script>
{{end}}
